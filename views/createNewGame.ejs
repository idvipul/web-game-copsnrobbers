<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <!--<title>* !!! *</title>-->
    <% include partials/head %>

    <script src="/socket.io/socket.io.js"></script>
        <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>

    <style>* { padding: 0; margin: 0; } canvas { background: #eee; display: block; margin: 0 auto; }</style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src = '/socket.io/socket.io.js'></script>
</head>
<body>

<canvas id="myCanvas" width="576" height="576"></canvas>

        <div class="col-md-3">Chats
                <ul id="messages-area2"></ul>
                <form id="form" onsubmit="return false;">
                        <input id="new-message2" type="text"/>
                        <button onclick="sendFunction2()">Send</button>
                    </form>
        </div>

<script>
    //game id
    //player id
    //
    // console.log("createNewGame.ejs--------"+"<%= gameid %>");

    var url = window.location.href;

    var path = url.split("/");
    path = path[4].split("?");
    var game_id = path[0];
    // var playerType = path[1].split("&");
    // var query = url.split("?",1);
    var playerType = url.split("=",2);
    playerType = playerType[1].split("&");
    // console.log(game_id);
    playerType = playerType[0];

    // console.log(query);
    // console.log(playerType[0]);
    function drawPlayerGlyph(xPos, yPos){
      if (playerType == '1'){
        ctx.fillText(cop_icon, xPos, yPos+gridSize);
      }
      else if (playerType == '2'){
        ctx.fillText(rob_icon, xPos, yPos+gridSize);
      }

    }





    //CANVAS
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
    //GRID
    var positionMatrix = [ // 24x24
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];
    //  To place an item on the grid
    // the grid needs to embed to the resoultion of the screen
    //   and then each item size is relevant to the number of items in the grid
    //
    var gridSize = parseInt(canvas.width/24);
    var playerGridXposition = gridSize;  //var something somthing
    var playerGridYposition = gridSize;
    var stepsPerMove = 5;
    //PLAYER
    var playerTokenHeight = gridSize;
    var playerTokenWidth = gridSize;
    var score = 0;
    var lives = 9;
    //KEY BINDINGS
    var rightPressed = false;
    var leftPressed = false;
    var upPressed = false;
    var downPressed = false;
    var enterPressed = false;
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    // document.addEventListener("mousemove", mouseMoveHandler, false);
    function keyDownHandler(e) {
        if(e.keyCode == 39) {
            rightPressed = true;
        }
        else if(e.keyCode == 37) {
            leftPressed = true;
        }
        else if(e.keyCode == 38) {
            upPressed = true;
        }
        else if(e.keyCode == 40) {
            downPressed = true;
        }
        else if(e.keyCode == 13) {
            enterPressed = true;
        }
    }
    function keyUpHandler(e) {
        if(e.keyCode == 39) {
            // stepsPerMove -= 1;
            rightPressed = false;
        }
        else if(e.keyCode == 37) {
            leftPressed = false;
        }
        else if(e.keyCode == 38) {
            upPressed = false;
        }
        else if(e.keyCode == 40) {
            downPressed = false;
        }
        else if(e.keyCode == 13) {
            enterPressed = false;
        }
    }
    var socket = io();
    // var socket = io('/my-namespace');

    socket.emit('joined room', game_id);
    // socket.to('game').emit('nice game', "let's play a game");
    function sendFunction2() {
        socket.emit('new message2', $('#new-message2').val());
        $('#new-message2').val('');
    }

    socket.on('chat message2', function (msg) {
        $('#messages-area2').append($('<li>').text(msg));
    });




    function sendFunction() {
        var move = {
            x:playerGridXposition/gridSize,
            y:playerGridYposition/gridSize
        }
        // io.to(game_id).emit('player move', move);
        socket.emit('player move', move, game_id);
    }
    socket.on('new move', function (move) {
        // console.log(stepsPerMove);
        var x = move.x;
        var y = move.y;
        positionMatrix[parseInt(x)][parseInt(y)] = 1;
        // ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGridState();
        // draw();
        // $('#messages-area').append($('<li>').text(msg));
    });
    function takePowerup() {
        var position = {
            x:playerGridXposition/gridSize,
            y:playerGridYposition/gridSize
        }
        console.log(position.x);
        positionMatrix[position.x][position.y] = 0;
        socket.emit('on powerup', position);
    }
    socket.on('powerup taken', function (position) {
        console.log(stepsPerMove);
        var x = position.x;
        var y = position.y;
        positionMatrix[parseInt(x)][parseInt(y)] = 0;
        // local_zoneupdate();
        // drawGridState();
        // draw();
        // $('#messages-area').append($('<li>').text(msg));
    });
    function drawBank(xPos, yPos) {
        ctx.font = "48px FontAwesome";
        ctx.fillText(usd_icon,xPos, yPos + gridSize);
        ctx.font = "24px FontAwesome";
    }
    function drawBreadCrumbs(xPos, yPos) {
        ctx.beginPath();
        ctx.rect(xPos + playerTokenWidth*3/8 , yPos+ playerTokenWidth*3/8, playerTokenWidth/8, playerTokenHeight/8);
        ctx.fillStyle = "#0094DD";
        ctx.fill();
        ctx.closePath();
    }
    function drawEnemyToken(xPos, yPos) {
        ctx.beginPath();
        ctx.rect(xPos, yPos, playerTokenWidth, playerTokenHeight);
        ctx.fillStyle = "#B22222";
        ctx.fill();
        ctx.closePath();
    }
    function drawScore() {
        ctx.font = "16px Arial";
        ctx.fillStyle = "#0095DD";
        ctx.fillText("Score: "+score, 8, 20);
    }
    function drawLives() {
        ctx.font = "16px Arial";
        ctx.fillStyle = "#0095DD";
        ctx.fillText("Lives: "+lives, canvas.width-65, 20);
    }
    function drawGridState() {
        for (var column = 0; column < 24; column++) {
            for (var row = 0; row < 24; row++) {
                // var tile = map.getTile(column, row);
                // var x = column * map.tileSize;
                // var y = row * map.tileSize;
                if (positionMatrix[row][column] == 1){
                    drawEnemyToken(row* gridSize, column* gridSize);
                }
                else if (positionMatrix[row][column] == -1){
                    drawBreadCrumbs(row* gridSize, column* gridSize);
                }
                else if (positionMatrix[row][column] == 5){
                    drawBank(row* gridSize, column* gridSize);
                }
                // else if (positionMatrix[row][column] == -1){
                //   drawPowerUps(row* gridSize, column* gridSize);
                // }
                // else if (positionMatrix[row][column] == -1){
                //   drawBreadCrumbs(row* gridSize, column* gridSize);
                // }
            }
        }
    }
    function drawPowerUps() {
    }
    // var xpos = (parseInt(playerGridXposition/gridSize));
    // var ypos = (parseInt(playerGridYposition/gridSize));
    const size = 24;
    var zone = 6;
    // const
    // only check within 5 moves of a player
    // update 5 grid boxes
    var icon_box = String.fromCharCode("0xf096");
    var usd_icon = String.fromCharCode("0xf155");
    var cop_icon = String.fromCharCode("0xf005");
    var rob_icon = String.fromCharCode("0xf21b");
    var exit_icon = String.fromCharCode("0xf2c6");
    // POWERUP ICONS
    //  TODO: reduce opacity
    var plus_icon = String.fromCharCode("0xf196");
    var attack_icon = String.fromCharCode("0xf255");
    var shield_icon = String.fromCharCode("0xf132");
    //  var
    //  var
    function local_zoneupdate(xpos, ypos) {
        for (var col = xpos - zone; col < xpos + zone ; col++) {
            for (var row = ypos - zone; row < ypos + zone; row++) {
                if (row >= 0 && row <= size && col >= 0 && col <= size){
                    // if (positionMatrix[row][col] == 1){
                    //   drawEnemyToken(row * gridSize, col * gridSize);
                    // }
                    if (positionMatrix[row][col] > 10){
                        if (positionMatrix[row][col] == 11){
                            ctx.fillText(plus_icon, row*gridSize, col*gridSize+gridSize);
                        }
                        //print
                        // usePowerup();
                        //
                        // drawBreadCrumbs(row * gridSize, col * gridSize);
                    }
                }
            }
        }
    }
    // var skip_icon // skip move
    // var lathiIcon
    var steps = [stepsPerMove];
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // ctx.clearRect(playerGridXposition - zone*gridSize/2, playerGridYposition - zone*gridSize/2, zone*gridSize, zone*gridSize);
        ctx.font = "24px FontAwesome";
        var xpos = (parseInt(playerGridXposition/gridSize));
        var ypos = (parseInt(playerGridYposition/gridSize));
        // ctx.fillText(usd_icon, canvas.width/2, canvas.height/2);
        ctx.fillText(cop_icon, canvas.width/4, canvas.height/4);
        ctx.fillText(exit_icon, canvas.width/3, canvas.height/3);
        ctx.fillText(plus_icon, 100, 200);
        ctx.fillText(shield_icon, 0, canvas.height );
        ctx.fillText(attack_icon, 100, 500);
        // for (var col = 0; col < 5; col++) {
        //   for (var row = 0; row < 5; row++) {
        //   //   if (row >= 0 && row < size && col >= 0 && col < size){
        //
        //   ctx.fillText(plus_icon, xpos + col, ypos + row )
        //   // }
        //   // }
        // }
        // }
        //  PLAYER MOVED
//      INLINE FUNCTION
        if (stepsPerMove >= 0){
            if(rightPressed && playerGridXposition < canvas.width-playerTokenWidth ) {
                rightPressed = false;
                if (positionMatrix [xpos+1][ypos] != -1 && stepsPerMove > 0){
                    positionMatrix[xpos][ypos] = -1;
                    stepsPerMove -= 1;
                    playerGridXposition += gridSize;
                }
                else if (positionMatrix[xpos+1][ypos] == -1){
                    positionMatrix[xpos][ypos] = 0;
                    stepsPerMove += 1;
                    playerGridXposition += gridSize;
                }
            }
            else if(leftPressed && playerGridXposition > 0 ) {
                leftPressed = false;
                if (positionMatrix [xpos-1][ypos] != -1 && stepsPerMove > 0){
                    positionMatrix[xpos][ypos] = -1;
                    stepsPerMove -= 1;
                    playerGridXposition -= gridSize;
                }
                else if (positionMatrix[xpos-1][ypos] == -1) {
                    positionMatrix[xpos][ypos] = 0;
                    stepsPerMove += 1;
                    playerGridXposition -= gridSize;
                }
            }
            else if(downPressed && playerGridYposition < canvas.height-playerTokenHeight ) {
                if (positionMatrix [xpos][ypos+1] != -1 && stepsPerMove > 0){
                    positionMatrix[xpos][ypos] = -1;
                    stepsPerMove -= 1;
                    playerGridYposition += gridSize;
                }
                else if (positionMatrix[xpos][ypos+1] == -1) {
                    positionMatrix[xpos][ypos] = 0;
                    stepsPerMove += 1;
                    playerGridYposition += gridSize;
                }
                downPressed = false;
            }
            else if(upPressed && playerGridYposition > 0 ) {
                if (positionMatrix[xpos][ypos-1] != -1 && stepsPerMove > 0){
                    positionMatrix[xpos][ypos] = -1;
                    stepsPerMove -= 1;
                    playerGridYposition -= gridSize;
                }
                else if (positionMatrix[xpos][ypos-1] == -1) {
                    positionMatrix[xpos][ypos] = 0;
                    stepsPerMove += 1;
                    playerGridYposition -= gridSize;
                }
                upPressed = false;
            }
            else if(enterPressed){
                enterPressed = false;
                //  get value of move.
                //  db.get vlu if last move
                //  if move
                sendFunction();
                stepsPerMove = 5;
            }
        }
        // drawPlayerToken(playerGridXposition, playerGridYposition);
        if (positionMatrix[xpos][ypos] > 10){
            takePowerup();
        }
        drawPlayerGlyph(playerGridXposition, playerGridYposition);
        steps[stepsPerMove] = [playerGridXposition, playerGridYposition];
        drawGridState();
        local_zoneupdate(xpos, ypos);
        drawScore();
        drawLives();
        requestAnimationFrame(draw);
    }
    draw();
    // console.log(stepsPerMove)
</script>
<!-- <script src = "draw.js"> </script> -->

</body>
</html>
